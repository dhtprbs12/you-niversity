// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: university.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "University.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - UniversityRoot

@implementation UniversityRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - UniversityRoot_FileDescriptor

static GPBFileDescriptor *UniversityRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@""
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - University

@implementation University

@dynamic universityId;
@dynamic name;
@dynamic ranking;
@dynamic website;
@dynamic address;
@dynamic numOfStudents;
@dynamic tuitionFee;
@dynamic sat;
@dynamic act;
@dynamic applicationFee;
@dynamic satAct;
@dynamic highSchoolGpa;
@dynamic acceptanceRate;
@dynamic crawlingURL;

typedef struct University__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *ranking;
  NSString *website;
  NSString *address;
  NSString *numOfStudents;
  NSString *tuitionFee;
  NSString *sat;
  NSString *act;
  NSString *applicationFee;
  NSString *satAct;
  NSString *highSchoolGpa;
  NSString *acceptanceRate;
  NSString *crawlingURL;
  int64_t universityId;
} University__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "universityId",
        .dataTypeSpecific.className = NULL,
        .number = University_FieldNumber_UniversityId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(University__storage_, universityId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = University_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(University__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ranking",
        .dataTypeSpecific.className = NULL,
        .number = University_FieldNumber_Ranking,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(University__storage_, ranking),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "website",
        .dataTypeSpecific.className = NULL,
        .number = University_FieldNumber_Website,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(University__storage_, website),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = University_FieldNumber_Address,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(University__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "numOfStudents",
        .dataTypeSpecific.className = NULL,
        .number = University_FieldNumber_NumOfStudents,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(University__storage_, numOfStudents),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tuitionFee",
        .dataTypeSpecific.className = NULL,
        .number = University_FieldNumber_TuitionFee,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(University__storage_, tuitionFee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sat",
        .dataTypeSpecific.className = NULL,
        .number = University_FieldNumber_Sat,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(University__storage_, sat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "act",
        .dataTypeSpecific.className = NULL,
        .number = University_FieldNumber_Act,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(University__storage_, act),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "applicationFee",
        .dataTypeSpecific.className = NULL,
        .number = University_FieldNumber_ApplicationFee,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(University__storage_, applicationFee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "satAct",
        .dataTypeSpecific.className = NULL,
        .number = University_FieldNumber_SatAct,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(University__storage_, satAct),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "highSchoolGpa",
        .dataTypeSpecific.className = NULL,
        .number = University_FieldNumber_HighSchoolGpa,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(University__storage_, highSchoolGpa),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "acceptanceRate",
        .dataTypeSpecific.className = NULL,
        .number = University_FieldNumber_AcceptanceRate,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(University__storage_, acceptanceRate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "crawlingURL",
        .dataTypeSpecific.className = NULL,
        .number = University_FieldNumber_CrawlingURL,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(University__storage_, crawlingURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[University class]
                                     rootClass:[UniversityRoot class]
                                          file:UniversityRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(University__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\016\010\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetUniversitiesRequest

@implementation GetUniversitiesRequest

@dynamic universityId;

typedef struct GetUniversitiesRequest__storage_ {
  uint32_t _has_storage_[1];
  int64_t universityId;
} GetUniversitiesRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "universityId",
        .dataTypeSpecific.className = NULL,
        .number = GetUniversitiesRequest_FieldNumber_UniversityId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetUniversitiesRequest__storage_, universityId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetUniversitiesRequest class]
                                     rootClass:[UniversityRoot class]
                                          file:UniversityRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetUniversitiesRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetUniversitiesResponse

@implementation GetUniversitiesResponse

@dynamic universitiesArray, universitiesArray_Count;

typedef struct GetUniversitiesResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *universitiesArray;
} GetUniversitiesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "universitiesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(University),
        .number = GetUniversitiesResponse_FieldNumber_UniversitiesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetUniversitiesResponse__storage_, universitiesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetUniversitiesResponse class]
                                     rootClass:[UniversityRoot class]
                                          file:UniversityRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetUniversitiesResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetAcceptibleUniversitiesRequest

@implementation GetAcceptibleUniversitiesRequest

@dynamic universityId;
@dynamic testType;
@dynamic score;
@dynamic gpaScore;

typedef struct GetAcceptibleUniversitiesRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *testType;
  NSString *score;
  NSString *gpaScore;
  int64_t universityId;
} GetAcceptibleUniversitiesRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "universityId",
        .dataTypeSpecific.className = NULL,
        .number = GetAcceptibleUniversitiesRequest_FieldNumber_UniversityId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetAcceptibleUniversitiesRequest__storage_, universityId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "testType",
        .dataTypeSpecific.className = NULL,
        .number = GetAcceptibleUniversitiesRequest_FieldNumber_TestType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetAcceptibleUniversitiesRequest__storage_, testType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "score",
        .dataTypeSpecific.className = NULL,
        .number = GetAcceptibleUniversitiesRequest_FieldNumber_Score,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetAcceptibleUniversitiesRequest__storage_, score),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gpaScore",
        .dataTypeSpecific.className = NULL,
        .number = GetAcceptibleUniversitiesRequest_FieldNumber_GpaScore,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetAcceptibleUniversitiesRequest__storage_, gpaScore),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetAcceptibleUniversitiesRequest class]
                                     rootClass:[UniversityRoot class]
                                          file:UniversityRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetAcceptibleUniversitiesRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetUniversityByNameRequest

@implementation GetUniversityByNameRequest

@dynamic name;

typedef struct GetUniversityByNameRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
} GetUniversityByNameRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = GetUniversityByNameRequest_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetUniversityByNameRequest__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetUniversityByNameRequest class]
                                     rootClass:[UniversityRoot class]
                                          file:UniversityRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetUniversityByNameRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetUniversityByNameResponse

@implementation GetUniversityByNameResponse

@dynamic hasUniversity, university;

typedef struct GetUniversityByNameResponse__storage_ {
  uint32_t _has_storage_[1];
  University *university;
} GetUniversityByNameResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "university",
        .dataTypeSpecific.className = GPBStringifySymbol(University),
        .number = GetUniversityByNameResponse_FieldNumber_University,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetUniversityByNameResponse__storage_, university),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetUniversityByNameResponse class]
                                     rootClass:[UniversityRoot class]
                                          file:UniversityRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetUniversityByNameResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
